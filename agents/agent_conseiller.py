# -*- coding: utf-8 -*-

import os
import json
# On importe la nouvelle biblioth√®que de Google
import google.generativeai as genai
import datetime
import logging

# Importation de TOUTES les fonctions de nos agents, qui deviendront des "outils" pour l'IA
from .agent_taches import (
    ajouter_tache, lister_taches, modifier_tache,
    supprimer_tache, changer_statut_tache,
    ajouter_sous_tache, lister_sous_taches, modifier_sous_tache,
    supprimer_sous_tache, changer_statut_sous_tache
)
from .agent_projets import (
    ajouter_projet, lister_projets, modifier_projet, supprimer_projet
)
from .agent_calendrier import (
    lister_prochains_evenements, creer_evenement_calendrier, modifier_evenement_calendrier,
    supprimer_evenement_calendrier, lister_tous_les_calendriers
)

# --- Configuration ---
# On configure l'API Google Gemini
try:
    genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))
    logger = logging.getLogger(__name__)
    logger.info("‚úÖ API Google Gemini configur√©e avec succ√®s.")
except Exception as e:
    # Cette log est cruciale si la cl√© API est manquante sur Railway
    logging.getLogger(__name__).error(f"üî• ERREUR: Impossible de configurer Google GenAI. La cl√© GOOGLE_API_KEY est-elle bien d√©finie dans les variables d'environnement ? Erreur: {e}")

# --- D√©finition de la "Bo√Æte √† Outils" Compl√®te (format OpenAI) ---
# On garde ce format car il est clair, on le convertira pour Gemini √† la vol√©e.
tools = [
    # Outils pour les T√¢ches
    {"type": "function", "function": {"name": "lister_taches", "description": "Obtenir la liste de toutes les t√¢ches, tri√©es par priorit√© (selon la matrice d'Eisenhower)."}},
    {"type": "function", "function": {"name": "ajouter_tache", "description": "Ajouter une nouvelle t√¢che. L'importance et l'urgence peuvent √™tre sp√©cifi√©es.", "parameters": {"type": "object", "properties": {"description": {"type": "string", "description": "Description de la t√¢che."}, "nom_projet": {"type": "string", "description": "Optionnel. Nom du projet associ√©."}, "important": {"type": "boolean", "description": "La t√¢che est-elle importante ?"}, "urgent": {"type": "boolean", "description": "La t√¢che est-elle urgente ?"}}, "required": ["description"]}}},
    {"type": "function", "function": {"name": "modifier_tache", "description": "Modifier une t√¢che (description, projet, importance, urgence). La priorit√© sera recalcul√©e automatiquement.", "parameters": {"type": "object", "properties": {"description_actuelle": {"type": "string", "description": "Description actuelle de la t√¢che √† modifier."}, "nouvelle_description": {"type": "string", "description": "Optionnel. La nouvelle description de la t√¢che."}, "nom_projet": {"type": "string", "description": "Optionnel. Le nouveau nom du projet pour la t√¢che."}, "nouvelle_importance": {"type": "boolean", "description": "Optionnel. Le nouveau statut d'importance."}, "nouvelle_urgence": {"type": "boolean", "description": "Optionnel. Le nouveau statut d'urgence."}}, "required": ["description_actuelle"]}}},
    {"type": "function", "function": {"name": "changer_statut_tache", "description": "Changer le statut d'une t√¢che (√† faire, en cours, termin√©e).", "parameters": {"type": "object", "properties": {"description_tache": {"type": "string", "description": "Description de la t√¢che √† modifier."}, "nouveau_statut": {"type": "string", "description": "Le nouveau statut."}}, "required": ["description_tache", "nouveau_statut"]}}},
    {"type": "function", "function": {"name": "supprimer_tache", "description": "Supprimer une t√¢che.", "parameters": {"type": "object", "properties": {"description_tache": {"type": "string", "description": "Description de la t√¢che √† supprimer."}}, "required": ["description_tache"]}}},
    
    # Outils pour les Sous-T√¢ches
    {"type": "function", "function": {"name": "ajouter_sous_tache", "description": "Ajouter une sous-t√¢che √† une t√¢che existante.", "parameters": {"type": "object", "properties": {"description_tache_parent": {"type": "string", "description": "Description de la t√¢che parent √† laquelle ajouter la sous-t√¢che."}, "description_sous_tache": {"type": "string", "description": "Description de la nouvelle sous-t√¢che."}, "important": {"type": "boolean", "description": "La sous-t√¢che est-elle importante ?"}, "urgent": {"type": "boolean", "description": "La sous-t√¢che est-elle urgente ?"}}, "required": ["description_tache_parent", "description_sous_tache"]}}},
    {"type": "function", "function": {"name": "lister_sous_taches", "description": "Lister toutes les sous-t√¢ches d'une t√¢che parent, tri√©es par priorit√©.", "parameters": {"type": "object", "properties": {"description_tache_parent": {"type": "string", "description": "Description de la t√¢che parent dont on veut voir les sous-t√¢ches."}}, "required": ["description_tache_parent"]}}},
    {"type": "function", "function": {"name": "modifier_sous_tache", "description": "Modifier une sous-t√¢che existante (description, importance, urgence).", "parameters": {"type": "object", "properties": {"description_tache_parent": {"type": "string", "description": "Description de la t√¢che parent."}, "description_sous_tache_actuelle": {"type": "string", "description": "Description actuelle de la sous-t√¢che √† modifier."}, "nouvelle_description": {"type": "string", "description": "Optionnel. La nouvelle description de la sous-t√¢che."}, "nouvelle_importance": {"type": "boolean", "description": "Optionnel. Le nouveau statut d'importance."}, "nouvelle_urgence": {"type": "boolean", "description": "Optionnel. Le nouveau statut d'urgence."}}, "required": ["description_tache_parent", "description_sous_tache_actuelle"]}}},
    {"type": "function", "function": {"name": "changer_statut_sous_tache", "description": "Changer le statut d'une sous-t√¢che (√† faire, en cours, termin√©e).", "parameters": {"type": "object", "properties": {"description_tache_parent": {"type": "string", "description": "Description de la t√¢che parent."}, "description_sous_tache": {"type": "string", "description": "Description de la sous-t√¢che."}, "nouveau_statut": {"type": "string", "description": "Le nouveau statut de la sous-t√¢che."}}, "required": ["description_tache_parent", "description_sous_tache", "nouveau_statut"]}}},
    {"type": "function", "function": {"name": "supprimer_sous_tache", "description": "Supprimer une sous-t√¢che d'une t√¢che parent.", "parameters": {"type": "object", "properties": {"description_tache_parent": {"type": "string", "description": "Description de la t√¢che parent."}, "description_sous_tache": {"type": "string", "description": "Description de la sous-t√¢che √† supprimer."}}, "required": ["description_tache_parent", "description_sous_tache"]}}},
    
    # Outils pour les Projets
    {"type": "function", "function": {"name": "lister_projets", "description": "Obtenir la liste de tous les projets avec leurs d√©tails (ID, nom, description, calendrier_associe, emoji)."}},
    {"type": "function", "function": {"name": "ajouter_projet", "description": "Cr√©er un nouveau projet. Une description, un calendrier et un √©moji peuvent √™tre sp√©cifi√©s.", "parameters": {"type": "object", "properties": {"nom": {"type": "string", "description": "Le nom du nouveau projet."}, "description": {"type": "string", "description": "Optionnel. Une description d√©taill√©e des objectifs du projet."}, "calendrier_associe": {"type": "string", "description": "Optionnel. Le nom du Google Calendar li√© √† ce projet."}, "emoji": {"type": "string", "description": "Optionnel. Un √©moji unique pour repr√©senter le projet (ex: 'üöÄ')."}}, "required": ["nom"]}}},
    {"type": "function", "function": {"name": "modifier_projet", "description": "Mettre √† jour le nom, la description, le calendrier ou l'√©moji d'un projet existant via son ID.", "parameters": {"type": "object", "properties": {"id_projet": {"type": "string", "description": "ID du projet √† modifier."}, "nouveau_nom": {"type": "string", "description": "Optionnel. Le nouveau nom du projet."}, "nouvelle_description": {"type": "string", "description": "Optionnel. La nouvelle description compl√®te du projet."}, "nouveau_calendrier": {"type": "string", "description": "Optionnel. Le nouveau nom du calendrier Google √† associer."}, "nouvel_emoji": {"type": "string", "description": "Optionnel. Le nouvel √©moji pour le projet."}}, "required": ["id_projet"]}}},
    {"type": "function", "function": {"name": "supprimer_projet", "description": "Supprimer un projet.", "parameters": {"type": "object", "properties": {"nom": {"type": "string", "description": "Nom du projet √† supprimer."}}, "required": ["nom"]}}},

    # Outils pour le Calendrier
    {"type": "function", "function": {"name": "lister_tous_les_calendriers", "description": "Obtenir la liste de tous les calendriers Google de l'utilisateur."}},
    {"type": "function", "function": {"name": "lister_prochains_evenements", "description": "Obtenir les prochains √©v√©nements. Peut chercher dans un calendrier sp√©cifique ou dans tous.", "parameters": {"type": "object", "properties": {"nom_calendrier": {"type": "string", "description": "Optionnel. Le nom du calendrier √† consulter."}}}}},
    {"type": "function", "function": {"name": "creer_evenement_calendrier", "description": "Cr√©e un nouvel √©v√©nement. Si le titre correspond √† une t√¢che existante, il utilisera intelligemment le calendrier du projet associ√© √† cette t√¢che.", "parameters": {"type": "object", "properties": {"titre": {"type": "string", "description": "Titre de l'√©v√©nement. Si cela correspond √† une t√¢che, utilise sa description exacte."}, "date_heure_debut": {"type": "string", "description": "Date et heure de d√©but au format ISO 8601 (YYYY-MM-DDTHH:MM:SS)."}, "date_heure_fin": {"type": "string", "description": "Date et heure de fin au format ISO 8601 (YYYY-MM-DDTHH:MM:SS)."}}, "required": ["titre", "date_heure_debut", "date_heure_fin"]}}},
    {"type": "function", "function": {"name": "modifier_evenement_calendrier", "description": "Modifier un √©v√©nement existant (titre, d√©but, fin) via son ID.", "parameters": {"type": "object", "properties": {"event_id": {"type": "string", "description": "ID de l'√©v√©nement √† modifier."}, "nouveau_titre": {"type": "string", "description": "Optionnel. Le nouveau titre de l'√©v√©nement."}, "nouvelle_date_heure_debut": {"type": "string", "description": "Optionnel. La nouvelle date et heure de d√©but au format ISO 8601."}, "nouvelle_date_heure_fin": {"type": "string", "description": "Optionnel. La nouvelle date et heure de fin au format ISO 8601."}}, "required": ["event_id"]}}},
    {"type": "function", "function": {"name": "supprimer_evenement_calendrier", "description": "Supprimer un √©v√©nement du calendrier avec son ID.", "parameters": {"type": "object", "properties": {"event_id": {"type": "string", "description": "ID de l'√©v√©nement √† supprimer."}}, "required": ["event_id"]}}},
]

# Mapping complet des outils
available_functions = {
    "lister_taches": lister_taches, "ajouter_tache": ajouter_tache, "modifier_tache": modifier_tache, "supprimer_tache": supprimer_tache, "changer_statut_tache": changer_statut_tache,
    "ajouter_sous_tache": ajouter_sous_tache, "lister_sous_taches": lister_sous_taches, "modifier_sous_tache": modifier_sous_tache, "supprimer_sous_tache": supprimer_sous_tache, "changer_statut_sous_tache": changer_statut_sous_tache,
    "lister_projets": lister_projets, "ajouter_projet": ajouter_projet, "modifier_projet": modifier_projet, "supprimer_projet": supprimer_projet,
    "lister_prochains_evenements": lister_prochains_evenements, "creer_evenement_calendrier": creer_evenement_calendrier, "modifier_evenement_calendrier": modifier_evenement_calendrier, "supprimer_evenement_calendrier": supprimer_evenement_calendrier,
    "lister_tous_les_calendriers": lister_tous_les_calendriers,
}


def router_requete_utilisateur(historique_conversation: list):
    """
    G√®re la conversation en utilisant Google Gemini.
    Cette fonction est le nouveau cerveau de l'IA.
    """
    logger.info("üß† ROUTEUR (GEMINI): Nouvelle requ√™te re√ßue, d√©but de l'analyse.")
    
    # 1. Pr√©paration des donn√©es pour Gemini
    historique_pour_gemini = []
    system_prompt = ""
    for message in historique_conversation:
        role = message["role"]
        if role == "system":
            system_prompt = message["content"]
            continue # Le prompt syst√®me est g√©r√© s√©par√©ment par Gemini
        
        # On adapte les r√¥les pour Gemini ('assistant' devient 'model')
        if role == "assistant":
            role = "model"
            
        historique_pour_gemini.append({'role': role, 'parts': [message["content"]]})

    try:
        # 2. Configuration du mod√®le Gemini
        # On utilise le mod√®le le plus r√©cent et performant comme demand√©.
        model = genai.GenerativeModel(
            model_name="gemini-2.5-pro",
            system_instruction=system_prompt,
            # On convertit notre liste d'outils au format que Gemini attend
            tools=[tool['function'] for tool in tools]
        )
        
        # 3. Boucle de conversation avec l'IA
        # On envoie l'historique et on attend la r√©ponse
        logger.info("üß† ROUTEUR (GEMINI): Envoi des informations √† Google Gemini...")
        response = model.generate_content(historique_pour_gemini)
        
        # 4. Traitement de la r√©ponse de l'IA (qui peut demander des outils)
        while response.candidates[0].content.parts and response.candidates[0].content.parts[0].function_call:
            # L'IA a demand√© d'utiliser un ou plusieurs outils
            function_calls = response.candidates[0].content.parts
            
            # On ajoute la demande de l'IA √† notre historique
            historique_pour_gemini.append(response.candidates[0].content)
            
            tool_responses = []
            
            for function_call in function_calls:
                call = function_call.function_call
                function_name = call.name
                args = dict(call.args)
                
                logger.info(f"üõ†Ô∏è OUTIL (GEMINI): L'IA demande l'ex√©cution de '{function_name}' avec les arguments: {args}")
                
                # On ex√©cute la fonction demand√©e
                function_to_call = available_functions.get(function_name)
                if function_to_call:
                    try:
                        function_response = function_to_call(**args)
                        # On pr√©pare la r√©ponse de l'outil pour la renvoyer √† l'IA
                        tool_responses.append({
                            "tool_call_id": function_call.id,
                            "role": "tool",
                            "name": function_name,
                            "content": json.dumps(function_response, ensure_ascii=False)
                        })
                    except Exception as e:
                        logger.error(f"üî• ERREUR: L'ex√©cution de la fonction '{function_name}' a √©chou√©: {e}")
                        # On informe l'IA que l'outil a √©chou√©
                        tool_responses.append({
                             "tool_call_id": function_call.id,
                             "role": "tool",
                             "name": function_name,
                             "content": json.dumps({"erreur": str(e)}, ensure_ascii=False)
                        })
                else:
                    logger.warning(f"‚ö†Ô∏è ATTENTION: L'IA a tent√© d'appeler une fonction inconnue: {function_name}")
            
            # On ajoute les r√©ponses des outils √† l'historique
            historique_pour_gemini.append({'role': 'tool', 'parts': [json.dumps(r) for r in tool_responses]})

            # On renvoie les r√©sultats √† l'IA pour qu'elle puisse formuler une r√©ponse finale
            logger.info("üß† ROUTEUR (GEMINI): Envoi des r√©sultats des outils √† Google Gemini pour la synth√®se finale...")
            response = model.generate_content(historique_pour_gemini)

        # 5. R√©ponse finale de l'IA (apr√®s les outils, ou directement)
        final_response_text = response.text
        logger.info("‚úÖ ROUTEUR (GEMINI): R√©ponse finale g√©n√©r√©e et pr√™te √† √™tre envoy√©e.")
        
        # On met √† jour l'historique principal pour le prochain tour
        # (c'est une simplification, le vrai historique est dans `historique_pour_gemini` mais on doit garder la structure)
        historique_conversation.append({"role": "assistant", "content": final_response_text})
        
        return final_response_text

    except Exception as e:
        logger.error(f"üî• ERREUR: L'appel √† l'API Google Gemini a √©chou√©: {e}")
        return f"D√©sol√©, une erreur de communication avec l'IA est survenue: {e}"


def generer_analyse_situation():
    """Version simplifi√©e pour √™tre appel√©e par le routeur."""
    # Cette fonction pourrait √™tre enrichie pour g√©n√©rer un prompt d'analyse plus complexe
    # mais pour l'instant, on se contente de signaler que la logique est ici.
    taches = lister_taches()
    projets = lister_projets()
    evenements = lister_prochains_evenements(5)

    # Ici, au lieu d'appeler l'IA (puisque c'est elle qui nous a appel√©s), 
    # on formate simplement les informations. L'intelligence est d√©j√† dans le choix de la fonction.
    return f"""
    --- Rapport de Situation ---
    
    Projets: {len(projets)}
    T√¢ches: {len(taches)}
    √âv√©nements √† venir: {len(evenements)}

    (Cette section peut √™tre enrichie pour une analyse plus d√©taill√©e sans re-appeler l'IA)
    """

def generer_contexte_complet():
    """
    G√©n√®re un contexte complet avec TOUTES les informations disponibles :
    - Tous les projets avec d√©tails complets
    - Toutes les t√¢ches avec sous-t√¢ches et priorit√©s
    - Agenda complet de la semaine pour tous les calendriers
    - Statistiques contextuelles
    """
    logger.info("üß† CONTEXTE: G√©n√©ration du contexte complet pour l'IA...")
    
    try:
        # === R√âCUP√âRATION DES DONN√âES ===
        projets = lister_projets()
        taches = lister_taches()
        calendriers = lister_tous_les_calendriers()
        
        # R√©cup√©rer les √©v√©nements de toute la semaine (7 jours) pour tous les calendriers
        evenements_semaine = lister_prochains_evenements(50)  # Plus d'√©v√©nements pour couvrir la semaine
        
        # === STATISTIQUES G√âN√âRALES ===
        total_projets = len(projets)
        total_taches = len(taches)
        
        # Statistiques des t√¢ches par priorit√©
        taches_p1 = [t for t in taches if t.get('priorite', '').startswith('P1')]
        taches_p2 = [t for t in taches if t.get('priorite', '').startswith('P2')]
        taches_p3 = [t for t in taches if t.get('priorite', '').startswith('P3')]
        taches_p4 = [t for t in taches if t.get('priorite', '').startswith('P4')]
        
        # Statistiques des t√¢ches par statut
        taches_a_faire = [t for t in taches if t.get('statut') == '√† faire']
        taches_en_cours = [t for t in taches if t.get('statut') == 'en cours']
        taches_terminees = [t for t in taches if t.get('statut') == 'termin√©e']
        
        # T√¢ches avec sous-t√¢ches
        taches_avec_sous_taches = [t for t in taches if t.get('sous_taches')]
        
        # === CONSTRUCTION DU CONTEXTE ===
        contexte = f"""
=== CONTEXTE COMPLET DE L'UTILISATEUR ===

üìä STATISTIQUES G√âN√âRALES :
- Projets actifs : {total_projets}
- T√¢ches totales : {total_taches}
- T√¢ches P1 (Urgent+Important) : {len(taches_p1)}
- T√¢ches P2 (Important) : {len(taches_p2)}
- T√¢ches P3 (Urgent) : {len(taches_p3)}
- T√¢ches P4 (Ni urgent ni important) : {len(taches_p4)}
- T√¢ches √† faire : {len(taches_a_faire)}
- T√¢ches en cours : {len(taches_en_cours)}
- T√¢ches termin√©es : {len(taches_terminees)}
- T√¢ches avec sous-t√¢ches : {len(taches_avec_sous_taches)}

üéØ PROJETS COMPLETS :"""

        if projets:
            for projet in projets:
                emoji = projet.get('emoji', 'üìÅ')
                nom = projet.get('nom', 'Sans nom')
                description = projet.get('description', 'Pas de description')
                calendrier = projet.get('calendrier_associe', 'Aucun calendrier')
                
                # Compter les t√¢ches de ce projet
                taches_projet = [t for t in taches if t.get('projet_id') == projet.get('id')]
                
                contexte += f"""
{emoji} {nom}
   Description: {description}
   Calendrier associ√©: {calendrier}
   T√¢ches li√©es: {len(taches_projet)}"""
        else:
            contexte += "\nAucun projet d√©fini."

        contexte += f"""

‚úÖ TOUTES LES T√ÇCHES (tri√©es par priorit√©) :"""

        if taches:
            priorite_actuelle = None
            for tache in taches:
                priorite = tache.get('priorite', 'Priorit√© inconnue')
                
                # Afficher le titre de la priorit√© si elle change
                if priorite != priorite_actuelle:
                    contexte += f"""

{priorite} :"""
                    priorite_actuelle = priorite
                
                # Informations de base de la t√¢che
                emoji_projet = tache.get('emoji_projet', 'üîπ')
                description = tache.get('description', 'Sans description')
                statut = tache.get('statut', 'inconnu')
                nom_projet = tache.get('nom_projet', 'Aucun projet')
                
                # Informations sur les sous-t√¢ches
                sous_taches = tache.get('sous_taches', [])
                resume_sous_taches = tache.get('resume_sous_taches')
                
                if resume_sous_taches:
                    progression = f" ({resume_sous_taches['terminees']}/{resume_sous_taches['total']} sous-t√¢ches termin√©es)"
                else:
                    progression = ""
                
                contexte += f"""
{emoji_projet} {description} [Statut: {statut}] [Projet: {nom_projet}]{progression}"""
                
                # D√©tailler les sous-t√¢ches si elles existent
                if sous_taches:
                    for sous_tache in sous_taches:
                        st_description = sous_tache.get('description', 'Sans description')
                        st_statut = sous_tache.get('statut', 'inconnu')
                        st_priorite = sous_tache.get('priorite', 'Inconnue')
                        statut_emoji = '‚úÖ' if st_statut == 'termin√©e' else 'üîÑ' if st_statut == 'en cours' else '‚è≥'
                        contexte += f"""
     {statut_emoji} {st_description} [{st_priorite}]"""
        else:
            contexte += "\nAucune t√¢che d√©finie."

        contexte += f"""

üìÖ AGENDA COMPLET DE LA SEMAINE :"""

        if calendriers:
            contexte += f"""
Calendriers disponibles : {', '.join([c.get('summary', 'Sans nom') for c in calendriers])}
"""

        if evenements_semaine:
            contexte += f"""
√âv√©nements √† venir ({len(evenements_semaine)} √©v√©nements) :"""
            for event in evenements_semaine:
                titre = event.get('summary', 'Sans titre')
                debut = event.get('start', 'Date inconnue')
                calendrier = event.get('calendar', 'Calendrier inconnu')
                contexte += f"""
üìÖ {titre} - {debut} [{calendrier}]"""
        else:
            contexte += "\nAucun √©v√©nement pr√©vu dans les prochains jours."

        contexte += """

=== FIN DU CONTEXTE ===
"""

        logger.info("‚úÖ CONTEXTE: Contexte complet g√©n√©r√© avec succ√®s.")
        return contexte
        
    except Exception as e:
        logger.error(f"üî• CONTEXTE: Erreur lors de la g√©n√©ration du contexte complet: {e}")
        return f"\n=== ERREUR DE CONTEXTE ===\nImpossible de charger le contexte complet: {e}\n"
